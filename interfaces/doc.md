# [接口](https://learnku.com/docs/the-way-to-go/what-is-the-111-interface/3647)

> 多态：同一种类型在不同类型的变量上表现出不同的行为



## [介绍](https://learnku.com/docs/the-way-to-go/what-is-the-111-interface/3647)

Go 语言不是 ”传统” 的面向对象编程语言，它里面没有类和继承的概念。但是 Go 语言里有非常灵活的**接口**概念，通过它可以实现很多面向对象的特性。

接口提供了一种方式来说明对象的行为：如果谁能搞定这件事，它就可以用在这儿。

接口定义了一组方法集，这些方法并没有实现。接口里不能包含变量。

```go
// Namer 是一个 接口类型
type Namer interface {
    Method1(param_list) return_type
    Method2(param_list) return_type
    ...
}
```

按照约定，只包含一个方法的接口的名字通常由方法名加 `[e]r` 后缀组成。

Go 语言中的接口都很简短，通常它们会包含0~3个方法。

在Go语言中接口类型可以有值（不像大多数面向对象编程语言，接口类型不可以有值），如

```go
// Namer是接口类型
// a是一个多字（multiword）数据结构, 值是nil. 它本质上是一个指针, 但又和指针有一定的差异
var a Namer
```

如果类型（如结构体）实现了接口Namer中的方法集，则此类型的变量（值或指针）可以赋值给接口变量，此时方法表中的指针会指向对应类型实现的接口方法。

> 此处的方法指针表是通过运行时反射实现的



## 特性

1. **类型不需要显式声明实现了某个接口，接口被隐式地实现。**

   如果希望**某个类型**显式地声明它们实现了这个接口，可以向接口的方法集中添加一个具有描述性名字的方法。如

   ```go
   type Fooer interface {
   	Foo()
   	MustImplementsFooer()  // 显式声明的描述性方法
   }
   ```

   大部分代码并不使用这样的约束，因为它限制了接口的实用性。但有些时候，这样的约束在大量相似的接口中被用来解决歧义。

2. 多个类型可以实现同一个接口。

3. 实现某个接口的类型（除了实现接口方法外）可以有其他的方法。

4. 一个类型可以实现多个接口。

5. 接口变量可以为一个**变量的引用**， 但是此变量的类型必须实现了此接口

   （实现接口中的方法集，接口是动态类型）

6. 即使接口在类型之后才定义，二者处于不同的包中，被单独编译：只要类型实现了接口中的方法，它就实现了此接口。

7. 一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。

8. 接口是一种契约，实现类型必须满足它，它描述了类型的行为，规定类型可以做什么。接口彻底将类型能做什么，以及如何做分离开来，使得相同接口的变量在不同的时刻表现出不同的行为，这就是多态的本质。

所有这些特性使得接口具有很大的灵活性。



## [接口嵌套](https://learnku.com/docs/the-way-to-go/112-interface-nesting-interface/3648)

一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中。

```go
type ReadWrite interface {
    Read(b Buffer) bool
    Write(b Buffer) bool
}

type Lock interface {
    Lock()
    Unlock()
}

// File 包含了 ReadWrite 和 Lock 的所有方法, 还额外有一个 Close() 方法
type File interface {
    ReadWrite
    Lock
    Close()
}
```



## 方法集

作用于变量上的方法不区分变量是值还是指针，因为编译器会转化成相应的接收者类型，但是当碰到接口类型时，这会变得有点复杂。**因为接口<u>变量中存储的具体值</u>是不可寻址的（不能拿到变量的地址）**，幸运的是，如果使用不当编译器会给出错误。

> 接口变量可以取地址，但是接口变量中**存储的具体值**是不可寻址的。



在**接口上调用方法**时，

- 接收者为指针的方法可以通过指针调用

- 接收者为值的方法可以通过值调用

- 接收者为值的方法可以通过指针调用

  因为指针会被自动解引用，转化成对应的值

- 接收者为指针的方法不可以通过值调用

  因为存储在接口中的值是不可寻址的（存储在变量中的值是不可寻址的，变量是可寻址的）

将一个值赋值给一个接口时，**编译器会确保所有可能的接口方法都可以在此值上被调用**，因此不正确的赋值在编译期就会失败。



**Go 语言规范定义了接口方法集的调用规则：**

- 类型 `*T` 的可调用方法集包含接收者为`*T` 和T 的所有方法集
- 类型 T 的可调用方法集只包含接收者为 T 的所有方法
- 类型 T 的可调用方法集不包含接收者为 `*T` 的方法



## 应用

1. 一个很好的例子是来自标准库的 `sort` 包，要对一组数字或字符串排序，只需要实现三个方法：反映元素个数的 `Len()`方法、比较第 `i` 和 `j` 个元素的 `Less(i, j)` 方法以及交换第 `i` 和 `j` 个元素的 `Swap(i, j)` 方法。

2. 判断某个类型是否实现了指定方法

   ```go
   type Stringer interface {
       String() string
   }
   
   if sv, ok := v.(Stringer); ok {
       fmt.Printf("v implements String(): %v\n", sv.String())
   }
   ```




## 空接口

**空接口或者最小接口** 不包含任何方法，它对实现不做任何要求（就是`interface{}`）：

```
type Any interface {}
```

任何其他类型都实现了空接口，`any` 或 `Any` 是空接口一个很好的别名或缩写。（类似于Python中的object）



## 总结

Go 没有类，而是松耦合的类型、方法对接口的实现。

面向对象语言最重要的三个方面分别是：封装，继承和多态，在 Go 中它们是怎样表现的呢？

封装（数据隐藏）：

+ 包范围内的：通过标识符首字母小写，`对象` 只在它所在的包内可见
+ 可导出的：通过标识符首字母大写，`对象` 对所在包以外也可见



类型只拥有自己所在包中定义的方法。

- 继承：用组合实现：内嵌一个（或多个）包含想要的行为（字段和方法）的类型；多重继承可以通过内嵌多个类型实现
- 多态：用接口实现：某个类型的值可以赋给它所实现的任意接口类型的变量。类型和接口是松耦合的，并且多重继承可以通过实现多个接口实现。
