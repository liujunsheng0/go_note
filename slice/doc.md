# [Go - array slice](https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/07.0.md)

## 数组

数组是具有相同**唯一类型**且长度固定的数据项序列，数组长度必须是一个常量表达式，并且必须是一个非负整数。数组长度也是数组类型的一部分，所以[5]int和[10]int是属于不同类型的。

> 函数传参时是值传递

### 初始化

```go
// 初始化为type的默认值
var varName [len]type

// 省略长度而采用...的方式, Go会自动根据元素个数来计算长度
varName := [...]int{4, 5, 6}

// 只有索引 1 和 2 被赋予实际的值, 其余元素被置为int默认值
varName := [5]int{1: 1, 2: 2}
```



## 切片

切片（slice）是是一个引用类型，对一个连续片段的引用（类似于Python 中的 list 类型）。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。需要注意的是，终止索引标识的项不包括在切片内。

切片提供了计算容量的函数 `cap()` 可以测量切片最长可以达到多少，它等于切片的长度 + 数组除切片之外的长度。如果 s 是一个切片，`cap(s)` 就是从 `s[0]` 到数组末尾的数组长度。切片的长度永远不会超过它的容量，所以对于 切片 s 来说该不等式永远成立：`0 <= len(s) <= cap(s)`。

**多个切片如果表示同一个数组的片段，它们可以共享数据；因此一个切片和相关数组的其他切片是共享存储的，相反，不同的数组总是代表不同的存储。**

### 初始化

```go
var varName []type

// 省略长度而采用...的方式, Go会自动根据元素个数来计算长度
varName := []int{4, 5, 6}

// 只有索引 1 和 2 被赋予实际的值, 其余元素被置为int默认值
varName = []int{1: 1, 2: 2}

// 赋予type的默认值, 长度为len, 容量为cap的切片, cap为可选项
varName := make([]type, len, cap) 
```



### 和数组区别

1. 和数组不同的是，切片的长度可以在运行时修改。
2. 参数传递时，切片是引用传递，数组是值传递
3. 因为切片是引用，所以它们不需要使用额外的内存，并且比使用数组更有效率，所以在 Go 代码中 切片比数组更常用
4. 切片本身已经是一个引用类型，所以它本身就是一个指针



## append

```go
func append(s[]T, x ...T) []T
```

其中 append 方法将 0 个或多个具有相同类型 s 的元素追加到切片后面并且返回新的切片；追加的元素必须和原切片的元素同类型。**如果 s 的容量不足以存储新增元素，append 会分配新的切片来保证已有切片元素和新增元素的存储。因此，返回的切片可能已经指向一个不同的相关数组了。**append 方法总是返回成功，除非系统内存耗尽了。

> 切片作为函数参数时，注意内存重新分配的问题。