# [Go - struct](https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/10.0.md)

## 定义结构体

```go
type structName struct {
    // 将类型作为结构体的字段，而不需要取变量名，这种字段叫匿名字段
	// 匿名字段，一个类型只能出现一种(此时类型和类型指针相同，只能出现一种)
	int
	string
    ... 
	
    // 结构体组合，类似于继承(Go中没有继承)
	// 匿名字段是struct时，那么这个struct所拥有的全部字段都被隐式地引入了当前定义的struct
    // 结构体变量.匿名字段中的属性 == 结构体变量.匿名字段.属性
	struct1
	struct2
	...
	structN

	// 结构体成员
	// 字段名首字母是小写的，意味着这些字段在包外不可见，因而无法在其他包中被访问，只允许包内访问.
	// 因此，如果想在一个包中访问另一个包中结构体的字段，则必须是大写字母开头的变量
	// 如果暂时不知道命名，可以使用 _ 来进行占位
	VarName1 VarType;
   	VarName2 VarType;
   	...
  	VarNameN VarType;
}
```



## 命名冲突

优先访问外层字段，外层名字会覆盖内层名字（但是两者的内存空间都保留），这提供了一种重载字段或方法的方式。

如果多个匿名字段中，包含了相同的字段，调用时需要指明匿名字段。



## 内存布局

struct中的所有字段在内存是连续的



## 方法

Go的方法是作用在接收者上的函数，接收者是某种类型的变量，因此方法是一种特殊类型的函数。因为方法是函数，所以方法不能被重载，相同类型只能有一个相同名称的方法。

定义格式

```go
// r 就像是面向对象语言中的 this / self，如果不需要r，可以使用_替换它
func (r receiverType) methodName(parmeterList) (returnList){
	...
}
// r是receiverType的值
// methodName是r的方法名
```

 这样编译器就知道这个方法属于哪个struct了

**receiverType为值和指针的区别？**

1. receiverType为值

   方法接收者接收到的是变量**副本**，不会影响原变量；

2.  receiverType为指针

   方法接收者接收到的是变量的**引用**，  会影响原变量；

> 1. **指针方法和值方法都可以在指针或值上被直接调用，因为编译器会自动转换成对应的类型**
>
> 2. **指针调用值方法时，不会影响原变量，值调用指针方法时，会影响原变量。**
>
>    **不管调用者为指针还是值，以接收者为准，接收者为指针，接收到的就是引用，接收者为值，接收到的就是副本**
>
> 3. Go中，结构体的定义和绑定在它上面的方法的代码可以放在不同文件中，但必须在同一个包中



## 结构体变量定义

1. ```go
   variableName := struct_name {VarName1: v1，VarName2: v2，... ，VarNameN: vn}
   ```

2. 直接定义结构体变量， 分配内存，并零值化内存
   这种使用方式并没有为字段赋初始值，因此所有字段都会被自动赋予对应类型的零值，如string类型的值为空字符串""，int类型的值为0

   

## 结构体指针定义
1. 直接定义结构体指针

   初始值为nil，不能访问字段；只有初始化后，才能访问字段或为字段赋值

2. 使用new定义结构体指针

   new可以分配内存来初始化结构休，并返回分配的内存指针，因为已经初始化了，所以可以直接访问字段

> **结构体与数组一样，都是值传递，当把数组或结构体作为实参传给函数的形参时，会复制一个副本，所以为了提高性能，一般使用结构体指针**



## String()方法

String()方法来定制类型的字符串形式的输出，如果类型定义了 String()方法，fmt.Print() 和 fmt.Println() 会自动使用 String() 方法。不要在 String() 方法里面调用涉及 String() 方法的方法，它会导致意料之外的错误，如

```go
// TT.String() 调用 fmt.Sprintf，而 fmt.Sprintf 又会反过来调用 TT.String()...,递归，很快就会导致内存溢出
type TT float64
func (t TT) String() string {
	return fmt.Sprintf("%v", t)
}
```



## 反射获取字段和方法
```go
s := struct
v1 := reflect.ValueOf(s)    // 能获取字段     仅能获取接收者为值的方法
v2 := reflect.ValueOf(&s)   // 不能获取字段   能获取所有方法
```

值类型在反射中不能寻找存储在变量中具体值的地址，所以值不能调用接收者为指针的方法。指针类型在反射中调用调用接收者为值的方法时，会自动解引用，转为对应的值，所以指针可以调用绑定的所有方法。（不确定，在学习接口时，推断而来）

> value reference  值引用
> anonymous        匿名